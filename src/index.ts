//INDEX
/*
Dependencias:
npm i -D typescript ts-node 

1) typescript: Es el compilador de TypeScript.
Convierte el c√≥digo TypeScript (.ts y .tsx) en JavaScript (.js).
Es necesario para trabajar con TypeScript en un proyecto.
(npx tsc). Requiere archivo de configuraci√≥n tsconfig.json

üìå compilerOptions: {}
1Ô∏è‚É£ outDir: "./dist"`
Especifica la carpeta de salida para los archivos compilados en JavaScript.
En este caso, TypeScript guardar√° los archivos .js en la carpeta dist/.

2Ô∏è‚É£ rootDir: "./src"`
Define la carpeta ra√≠z del c√≥digo fuente.
Solo los archivos dentro de src/ ser√°n compilados.

3Ô∏è‚É£ lib: ["ESNext"]
Indica qu√© caracter√≠sticas de JavaScript estar√°n disponibles.
"ESNext" habilita las √∫ltimas versiones de ECMAScript (por ejemplo, async/await, Promise, etc.).

4Ô∏è‚É£ strict: false
Desactiva todas las verificaciones estrictas de TypeScript.
Si fuera true, habilitar√≠a reglas como strictNullChecks, noImplicitAny, etc.

5Ô∏è‚É£ sourceMap: true
Genera mapas de fuente (.map) para depuraci√≥n.
Permite que las herramientas como Chrome DevTools muestren TypeScript en lugar 
del c√≥digo JavaScript transpilado.

6Ô∏è‚É£ esModuleInterop: true
Habilita la interoperabilidad entre m√≥dulos CommonJS y ESModules.
Permite importar m√≥dulos de Node.js (require) usando import.

7Ô∏è‚É£ declaration: true
Genera archivos .d.ts con definiciones de tipos.
√ötil si vas a publicar una librer√≠a en TypeScript.

8Ô∏è‚É£ removeComments: true 
Elimina todos los comentarios en el c√≥digo de salida compilado. 
Los comentarios se descartan completamente y no aparecer√°n en los archivos JavaScript generados.

9Ô∏è‚É£ experimentalDecorators: true
Habilita el uso de decoradores en TypeScript.

üîü emitDecoratorMetadata": true
Permite que TypeScript genere metadatos de tipo para los decoradores, lo cual es clave para que 
Sequelize pueda inferir los tipos de datos correctamente.

1Ô∏è‚É£1Ô∏è‚É£ target: "ESNext"
La opci√≥n target controla la versi√≥n de JavaScript a la que TypeScript compilar√° tu c√≥digo.
Con "ESNext", le est√°s diciendo a TypeScript que compile tu c√≥digo a la versi√≥n m√°s reciente 
de ECMAScript disponible.

1Ô∏è‚É£2Ô∏è‚É£ moduleResolution: "Nodenext"
La opci√≥n moduleResolution le dice a TypeScript c√≥mo resolver los m√≥dulos al importar archivos.
Con "Nodenext", se le dice a TypeScript que use el mismo algoritmo de resoluci√≥n de 
m√≥dulos que Node.js con soporte de m√≥dulos ES (import/export).

1Ô∏è‚É£3Ô∏è‚É£ module: "NodeNext"
La opci√≥n module controla c√≥mo TypeScript genera los m√≥dulos cuando compila el c√≥digo.
"NodeNext" le dice a TypeScript que compile los m√≥dulos usando el formato ECMAScript Modules (ESM) 
de Node.js, que es lo m√°s moderno y est√°ndar.

üìå include: []
Define qu√© archivos deben ser compilados.
En este caso significa todos los archivos .ts dentro de src/ y sus subcarpetas.

üìå exclude: []
Define qu√© archivos no deben ser compilados.

2) ts-node:  Permite ejecutar archivos TypeScript directamente en Node.js, sin necesidad 
de compilarlos previamente.
Es √∫til para scripts, pruebas r√°pidas o entornos de desarrollo donde no quieres compilar 
manualmente el c√≥digo.
Se usa com√∫nmente junto con nodemon para recargar autom√°ticamente los cambios.
(npx ts-node src/index.ts)

npm i -D nodemon

1) nodemon: Es una herramienta que reinicia autom√°ticamente la aplicaci√≥n cuando 
detecta cambios en los archivos.
Muy √∫til en entornos de desarrollo para no tener que ejecutar manualmente 'node app.js '
cada vez que se cambia algo.
Funciona con JavaScript y TypeScript (junto con ts-node).
*"dev": "nodemon --exec ts-node src/index.ts" -> npm run dev

npm i express

1) express: Framework minimalista para construir servidores y APIs en Node.js.
Maneja rutas (GET, POST, PUT, DELETE...) f√°cilmente.
Permite trabajar con middlewares para modificar solicitudes/respuestas.
Facilita el manejo de JSON, archivos est√°ticos y sesiones.
Compatible con WebSockets, autenticaci√≥n, bases de datos, etc.

npm i -D @types/express

1) @types/express: Esto proporciona autocompletado y validaci√≥n de tipos para el c√≥digo TypeScript.
En este caso utilizamos la versi√≥n @4.17.20 compatible con express-validator.

npm i dotenv

1) dotenv: Permite cargar variables de entorno desde un archivo .env en Node.js.
En la ra√≠z del proyecto, crea un archivo .env con las variables de entorno

npm i colors

1) colors: Es una biblioteca de Node.js que te permite dar formato y color a 
la salida en la terminal. Es √∫til cuando quieres mejorar la visualizaci√≥n de logs, 
mensajes de error, o cualquier texto que se muestre en la consola.

npm i express-validator

1) express-validator: Es una librer√≠a de validaci√≥n para Express.js, basada en validator.js, 
que permite validar y sanitizar datos de las solicitudes (req.body, req.params, req.query).
*/

/*
ORM NodeJs
Un ORM (Object-Relational Mapping, Mapeo Objeto-Relacional) es una herramienta que permite 
interactuar con bases de datos usando objetos y m√©todos en lugar de SQL puro.
-Traduce c√≥digo en objetos a consultas SQL autom√°ticamente.
-Facilita la manipulaci√≥n de datos sin escribir SQL manualmente.
-Abstrae la estructura de la base de datos, permitiendo cambiar de motor f√°cilmente 
(MySQL, PostgreSQL, etc.).

En Node.js, los ORMs m√°s populares son:
üîπ Sequelize (https://sequelize.org/docs/v6/getting-started/)
Soporta PostgreSQL, MySQL, SQLite y MSSQL.
Usa modelos para definir estructuras de tablas.

üîπ Prisma
ORM moderno y r√°pido.
Tiene autocompletado de tipos en TypeScript.
Usa un archivo schema.prisma para definir modelos.

üîπ TypeORM
ORM basado en decoradores y clases en TypeScript.
Compatible con MySQL, PostgreSQL, SQLite, MongoDB, etc.

üîπ Mongoose
Mongoose es un ODM (Object-Document Mapping), similar 
a un ORM pero dise√±ado para MongoDB, que es una base de 
datos NoSQL basada en documentos.

‚úî Si quieres flexibilidad y compatibilidad con muchas bases de datos: Sequelize.
‚úî Si buscas rendimiento y facilidad con TypeScript: Prisma.
‚úî Si prefieres trabajar con decoradores y clases: TypeORM.
‚úî Si trabajs exclusivamente con MongoDB (NoSQL): Mongoose

npm i --save sequelize
npm i sequelize-typescript
npm i --save pg pg-hstore

--Render
https://dashboard.render.com/project/prj-cvgq5atds78s73dq9ou0

--DBEaver
DBeaver es una herramienta de c√≥digo abierto y multiplataforma para la administraci√≥n 
de bases de datos. Est√° dise√±ada para interactuar con diferentes motores de bases de datos, 
tanto relacionales como NoSQL, y proporciona una interfaz gr√°fica para realizar operaciones 
de gesti√≥n, desarrollo y administraci√≥n de bases de datos.

1) Compatibilidad con m√∫ltiples bases de datos:
Soporta una amplia variedad de bases de datos, como:
Relacionales: MySQL, PostgreSQL, SQLite, Oracle, SQL Server, etc.
NoSQL: MongoDB, Cassandra, Redis, etc.
Bases de datos en la nube: Amazon RDS, Google Cloud SQL, Azure SQL, etc.
2) Interfaz gr√°fica de usuario (GUI).
3) Editor SQL.
4) Gesti√≥n de esquemas y datos.
5) Exportaci√≥n e importaci√≥n de datos.
6) Soporte para m√∫ltiples conexiones.
7) Extensiones y personalizaci√≥n.

||Conexi√≥n
Nueva conexi√≥n: Host, Puerto, Database, Usuario, Contrase√±a
*/

/*
Testing
1) Supertest (npm i -D supertest @types/supertest)
Es una librer√≠a para pruebas de APIs que funciona sobre SuperAgent.
Permite enviar solicitudes HTTP a servidores y verificar respuestas.
Se usa junto con Jest u otros frameworks de prueba como Mocha o Chai.

2) Jest (npm i -D jest @types/jest ts-jest / npx ts-jest config:init)
Es un framework de testing desarrollado por Facebook.
Se usa para pruebas unitarias e integraci√≥n en aplicaciones JavaScript y TypeScript.
Incluye funcionalidades como mocking, snapshots y un runner r√°pido.
No requiere configuraciones adicionales en la mayor√≠a de los casos.
*"test": "jest --detectOpenHandles" -> npm run test¬®
*detectOpenHandles: Detecta y muestra recursos abiertos que podr√≠an estar causando que las 
pruebas no terminen correctamente.

-En conjunto
Jest proporciona el entorno de prueba y las aserciones.
SuperTest permite interactuar con la API y hacer peticiones HTTP.
Ambos juntos permiten realizar pruebas de integraci√≥n para validar 
que la API responde correctamente.

3) Code Coverage
El Code Coverage (cobertura de c√≥digo) mide qu√© porcentaje de tu c√≥digo es ejecutado durante 
las pruebas automatizadas. En un servidor Express con Node.js, puedes usar herramientas como 
Jest con Istanbul (via jest --coverage) para generar un informe de cobertura.
"test:coverage": "jest --detectOpenHandles --coverage"

-File	Archivo analizado.
-% Stmts	Statements: Porcentaje de l√≠neas ejecutadas en total.
-% Branch	Branches: Cobertura de estructuras de control (if, switch, ternarios, etc.).
-% Funcs	Functions: Porcentaje de funciones y m√©todos ejecutados.
-% Lines	Lines: Similar a Stmts, pero cuenta l√≠neas espec√≠ficas en vez de declaraciones generales.
-Uncovered Line #s	L√≠neas espec√≠ficas que no se ejecutaron en las pruebas.
*/

/*
Documentaci√≥n.
La documentaci√≥n de una API es una gu√≠a detallada que explica c√≥mo utilizarla, incluyendo 
sus endpoints, m√©todos HTTP, par√°metros, respuestas, autenticaci√≥n y ejemplos de uso. 
Es esencial para que otros desarrolladores (o incluso t√∫ en el futuro) puedan integrarla sin problemas.

Algunas secciones clave que debe incluir una buena documentaci√≥n de API:
-Introducci√≥n: Explica brevemente qu√© hace la API y su prop√≥sito.
-Autenticaci√≥n: Si es necesaria, describe c√≥mo obtener y usar las credenciales.
-Endpoints: Lista las rutas disponibles con sus m√©todos HTTP (GET, POST, PUT, DELETE, etc.).
-Par√°metros: Detalla los par√°metros requeridos y opcionales en cada endpoint.
-C√≥digos de estado HTTP: Explica los posibles errores y respuestas exitosas.
-Ejemplos de uso: Muestra c√≥mo hacer llamadas a la API con herramientas como Postman o 
c√≥digo en distintos lenguajes.
-Esquema de respuesta: Explica la estructura de los datos devueltos por la API.

Para documentarla puedes usar herramientas como:
-Swagger (OpenAPI): Genera documentaci√≥n interactiva autom√°ticamente.
-Postman: Permite describir la API y compartirla f√°cilmente.
-Redoc: Ofrece documentaci√≥n visual basada en OpenAPI.
-GitHub/GitLab Wikis o Markdown: Para documentaci√≥n m√°s manual pero estructurada.

1) Swagger
npm i swagger-jsdoc swagger-ui-express
Types: npm i -D @types/swagger-jsdoc @types/swagger-ui-express

Swagger es un conjunto de herramientas para documentar, dise√±ar, probar y visualizar APIs REST.
Su n√∫cleo es OpenAPI Specification (OAS), un est√°ndar que define c√≥mo debe estructurarse la 
documentaci√≥n de una API.
‚úÖ Genera documentaci√≥n interactiva
‚úÖ Permite probar endpoints desde la interfaz
‚úÖ Facilita la integraci√≥n con clientes y otros desarrolladores
‚úÖ Reduce errores al definir la API con un esquema estructurado

Componentes principales de Swagger:
-Swagger UI ‚Äì Interfaz visual interactiva que permite explorar y probar la API.
-Swagger Editor ‚Äì Un editor basado en web para escribir documentaci√≥n en OpenAPI.
-Swagger Codegen ‚Äì Genera c√≥digo cliente y servidor basado en la documentaci√≥n.

1Ô∏è‚É£ swagger-jsdoc
Permite escribir la documentaci√≥n en formato JSDoc dentro de los comentarios de tu c√≥digo.
Genera un esquema OAS basado en esas anotaciones.

2Ô∏è‚É£ swagger-ui-express
Sirve la documentaci√≥n de Swagger en una interfaz web interactiva.
Te permite probar los endpoints directamente desde el navegador.
*/

/*
CORS
npm i cors + npm i -D @types/cors

Cross-Origin Resource Sharing (Compartici√≥n de recursos entre or√≠genes distintos)
Por seguridad, los navegadores bloquean las peticiones HTTP que van de un origen 
diferente al servidor al que se est√° consultando. CORS permite que ciertos or√≠genes 
tengan permiso para hacer peticiones a tu backend.

El paquete cors es un middleware para Express (u otros frameworks) que agrega autom√°ticamente 
los encabezados HTTP correctos para permitir esas conexiones.
*/

/*
Morgan - Logging
npm i morgan + npm i -D @types/morgan

Morgan es un middleware para Node.js (usualmente con Express) que sirve para registrar (loggear) 
solicitudes HTTP en √±a aplicaci√≥n. Es √∫til para ver qu√© peticiones llegan al servidor, cu√°ndo y 
con qu√© datos, lo que facilita el debug y el monitoreo.
Morgan se inyecta como middleware en Express, lo que significa que se ejecuta cada vez que se 
recibe una petici√≥n HTTP antes de que llegue a la l√≥gica final.
*/
import server from "./server"
import colors from 'colors'

//Puerto del Servidor
//process.env.PORT: despliegue en un servicio, asignado din√°micamente
const port = process.env.PORT || 4000; 

//Arranque del ervidor Express, escuchando en el puerto definido
server.listen(port, () => {
    console.log(colors.cyan.bold(`REST API en el Puerto ${port}`));
});
